---
title: "Jittering: a flexible approach for converting OD data into geographic desire lines, routes and route networks for transport planning"
bibliography: foss4g2022.bib
author: Robin Lovelace, Rosa Félix, Dustin Carlino
# output: github_document
output:
  bookdown::pdf_document2:
    template: ISPRStemplate.tex
editor_options: 
  markdown: 
    wrap: sentence
---

```{r, eval=FALSE, echo=FALSE}
unzip("ISPRSguidelines_authors_fullpaper_latex_2021_09_09.zip")
tinytex::pdflatex("ISPRSguidelines_authors_fullpaper.tex")
rmarkdown::render("README.Rmd")
file.rename("README.pdf", "foss4g-paper-jittering.pdf")
browseURL("foss4g-paper-jittering.pdf")
piggyback::pb_upload("foss4g-paper-jittering.pdf")
```

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE,
  message = FALSE,
  cache = TRUE,
  warning = FALSE,
  fig.align = "center"
  # eval = FALSE
)
```

```{r, include=FALSE}
# devtools::install_github("itsleeds/od")
library(sf)
library(tmap)
library(tidyverse)
library(stplanr)
library(cyclestreets)
# rbbt::bbt_update_bib(path_rmd = "README.Rmd", path_bib = "foss4g2022.bib")
```

# Introduction

Origin-destination (OD) datasets provide information on aggregate travel patterns between zones and geographic entities.
OD datasets are 'implicitly geographic', containing identification codes of the geographic objects from which trips start and end.
A common approach to converting OD datasets to geographic entities, for example represented using the simple features standard [@ogcopengeospatialconsortiuminc_opengis_2011] and saved in file formats such as GeoPackage and GeoJSON, is to represent each OD record as a straight line between zone centroids. This approach to representing OD datasets on the map has been since at least the 1950s [@boyce_forecasting_2015] and is still in use today [e.g. @rae_spatial_2009].

Beyond simply visualising aggregate travel patterns, centroid-based geographic desire lines are also used as the basis of many transport modelling processes.
The following steps can be used to convert OD datasets into route networks, in a process that can generate nationally scalable results [@morgan_travel_2020]:

-   OD data converted into centroid-based geographic desire lines

-   Calculation of routes for each desire line, with start and end points at zone centroids

-   Aggregation of routes into route networks, with values on each segment representing the total amount of travel ('flow') on that part of the network, using functions such as `overline()` in the open source R package `stplanr` [@lovelace_stplanr_2018]

This approach is tried and tested.
The OD -\> desire line -\> route -\> route network processing pipeline forms the basis of the route network results in the Propensity to Cycle Tool, an open source and publicly available map-based web application for informing strategic cycle network investment, 'visioning' and prioritisation [@lovelace_propensity_2017; @goodman_scenarios_2019].
However, the approach has some key limitations:

-   Flows are concentrated on transport network segments leading to zone centroids, creating distortions in the results and preventing the simulation of the diffuse networks that are particularly important for walking and cycling

-   The results are highly dependent on the size and shape of geographic zones used to define OD data

-   The approach is inflexible, providing few options to people who want to use valuable OD datasets in different ways

To overcome these limitations we developed a 'jittering' approach to conversion of OD datasets to desire lines that randomly samples points within each zone [@Lovelace2022Jittering].
While that paper discussed the conceptual development of the approach, it omitted key details on its implementation in open source software.

In this paper we outline the implementation of jittering and demonstrate how a single Rust crate can provide the basis of implementations in other languages.
Furthermore, we demonstrate how jittering can be used to create more diffuse and accurate estimates of movement at the level of segments ('flows') on transport network, in reproducible code-driven workflows and with minimal computational overheads compared with the computationally intensive process of route calculation ('routing') or processing large GPS datasets.
The overall aim is to describe the jittering approach in technical terms and its implementation in open source software.

Before describing the approach, some definitions are in order:

-   **Origins**: locations of trip departure, typically stored as ID codes linking to zones

-   **Destinations**: trip destinations, also stored as ID codes linking to zones

-   **Attributes**: the number of trips made between each 'OD pair' and additional attributes such as route distance between each OD pair

-   **Jittering**: The combined process of 'splitting' OD pairs representing many trips into multiple 'sub OD' pairs (disaggregation) and assigning origins and destinations to multiple unique points within each zone

# Approach

Jittering represents a comparatively simple --- compared with 'connector' based methods [@jafari_investigation_2015] --- approach is to OD data preprocessing.
For each OD pair, the jittering approach consists of the following steps for each OD pair (provided it has required inputs of a disaggregation threshold, a single number greater than one, and sub-points from which origin and destination points are located):

1.  Checks if the number of trips (for a given 'disaggregation key', e.g. 'walking') is greater than the disaggregation threshold.
2.  If so, the OD pair is disaggregated. This means being divided into as many pieces ('sub-OD pairs') as is needed, with trip counts divided by the number of sub-OD pairs, for the total to be below the disaggregation threshold.
3.  For each sub-OD pair (or each original OD pair if no disaggregation took place) origin and destination locations are randomly sampled from sub-points which optionally have weights representing relative probability of trips starting and ending there.

This approach has been implemented efficiently in the Rust crate `odjitter`, the source code of which can be found at <https://github.com/dabreegster/odjitter>.

## Case study

Lisbon, Portugal, is a city with about half million residents. By 2018, when a mobility survey was carried on, and only about 0.5% of trips were made by bicycle. However, the investments in cycling infrastructure, reaching 150 km of cycling network in 2021, and the implementation of a dock-based bike-sharing system had a major impact on cycling levels [@felix2020build]

Cyclists’ counts are performed yearly from 2017 to 2021 at 45 locations in Lisbon during morning and
afternoon peak hours (8-10 am and 5-7 pm). In 2021, these were carried out in October.
The 67 locations, shown in Figure 1, are chosen considering to the existent and planned
cycling infrastructure, and places where there was no cycling infrastructure, but had already some presence
of cyclists.

We use data from this mobility survey [@IMOB] at district level (Lisbon has 24 districts) to compare with the ... 
Routes are computed using _Cyclestreets_, which relies on 2022 road network from OpenStreetMap. 

# Results

Jittering leads to more spatially diffuse representations of OD datasets than the common approach to desire lines that go from and to zone centroids.
We have used the approach to add value to numerous OD datasets for projects based in Ireland, Norway, Portugal, New Zealand and beyond.

In this particular case, Biclar project... validadion of the used method.

Figure \@ref(fig:lisbon1) shows the difference between desire lines with centroids approach and the jittering approach.

```{r lisbon1, include=FALSE, cache=TRUE, fig.cap="Illustration of jittered (left) compared with unjittered (right) origin-destination data."}
od_all = readRDS(url("https://github.com/U-Shift/biclar/releases/download/0.0.1/TRIPSmode_freguesias.Rds"))
zones = readRDS(url("https://github.com/U-Shift/biclar/releases/download/0.0.1/FREGUESIASgeo.Rds"))
osm_data_region = readRDS(url("https://github.com/U-Shift/biclar/releases/download/0.0.1/osm_data_region.Rds"))
```

```{r include=FALSE, cache=TRUE}
## For Lisbon only 
lisbon_zones = zones %>% filter(Concelho == "Lisboa")
od_lisbon = od_all %>% 
  filter(DICOFREor11 %in% lisbon_zones$Dicofre & DICOFREde11 %in% lisbon_zones$Dicofre)
od_lisbon_with_bikes = od_lisbon %>% filter(Bike > 0)
od_lisbon_sf = od::od_to_sf(od_lisbon_with_bikes, lisbon_zones) #desire lines

set.seed(42)
od_lisbon_jittered = odjitter::jitter(  #jitter
  od = od_lisbon_with_bikes,
  zones = lisbon_zones,
  subpoints = osm_data_region,
  disaggregation_key = "Total",
  disaggregation_threshold = round(max(od_lisbon_with_bikes$Total) + 1) ##30? 50? 100?
)
od_lisbon_jittered_500 = odjitter::jitter(  #jitter
  od = od_lisbon_with_bikes,
  zones = lisbon_zones,
  subpoints = osm_data_region,
  disaggregation_key = "Total",
  disaggregation_threshold = 500 ##30? 50? 100?
)
od_lisbon_jittered_200 = odjitter::jitter(  #jitter
  od = od_lisbon_with_bikes,
  zones = lisbon_zones,
  subpoints = osm_data_region,
  disaggregation_key = "Total",
  disaggregation_threshold = 200 ##30? 50? 100?
)
# nrow(od_lisbon_jittered) # 9042 (17784 with 100 disagreg_thr)
```

```{r}
counters = readxl::read_excel("DadosAbertos_IST_CML_ContagensCiclistas_20172021.xlsx", sheet = "Out2021")
counters_sf = counters %>% 
  filter(TurnoNor %in% c("M1", "M2", "T1", "T2")) %>% 
  group_by(Ponto) %>% 
  summarise(SumCiclistas = sum(SumCiclistas, na.rm = TRUE), lon = mean(lon), lat = mean(lat)) %>% 
  select(-Ponto) %>% 
  sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

```{r jitteredoverview, echo=FALSE, fig.cap="\\label{poltlisbon}Trips represented with desire lines from centroids and with jittering (no disagregation and with disagregation), for Lisbon (Portugal)", fig.show='hold', fig.ncol=2, out.width="50%"}
plot(od_lisbon_sf$geometry, lwd = 0.2)
plot(counters_sf, col = "red", add = TRUE)
plot(od_lisbon_jittered$geometry, lwd = 0.1)
plot(counters_sf, col = "red", add = TRUE)
plot(od_lisbon_jittered_500$geometry, lwd = 0.1)
plot(counters_sf, col = "red", add = TRUE)
```

```{r, eval=FALSE, echo=FALSE}
# Routing unjittered:
routes_unjittered_quietest = route(l = od_lisbon_sf , route_fun = journey, plan = "quietest")
write_rds(routes_unjittered_quietest, "routes_unjittered_quietest.Rds")
routes_unjittered_balanced = route(l = od_lisbon_sf , route_fun = journey, plan = "balanced")
write_rds(routes_unjittered_balanced, "routes_unjittered_balanced.Rds")
routes_unjittered_fastest = route(l = od_lisbon_sf , route_fun = journey, plan = "fastest")
write_rds(routes_unjittered_fastest, "routes_unjittered_fastest.Rds")
# Routing unjittered:
routes_jittered_quietest = route(l = od_lisbon_jittered , route_fun = journey, plan = "quietest")
write_rds(routes_jittered_quietest, "routes_jittered_quietest.Rds")
routes_jittered_balanced = route(l = od_lisbon_jittered , route_fun = journey, plan = "balanced")
write_rds(routes_jittered_balanced, "routes_jittered_balanced.Rds")
routes_jittered_fastest = route(l = od_lisbon_jittered , route_fun = journey, plan = "fastest")
write_rds(routes_jittered_fastest, "routes_jittered_fastest.Rds")
# Routing jittered 500:
routes_jittered_500_quietest = route(l = od_lisbon_jittered_500 , route_fun = journey, plan = "quietest")
write_rds(routes_jittered_500_quietest, "routes_jittered_500_quietest.Rds")
routes_jittered_500_balanced = route(l = od_lisbon_jittered_500 , route_fun = journey, plan = "balanced")
write_rds(routes_jittered_500_balanced, "routes_jittered_500_balanced.Rds")
routes_jittered_500_fastest = route(l = od_lisbon_jittered_500 , route_fun = journey, plan = "fastest")
write_rds(routes_jittered_500_fastest, "routes_jittered_500_fastest.Rds")

```

```{r}
routes_unjittered_quietest = readRDS("routes_unjittered_quietest.Rds")
routes_unjittered_balanced = readRDS("routes_unjittered_balanced.Rds")
routes_unjittered_fastest = readRDS("routes_unjittered_fastest.Rds")
routes_jittered_quietest = readRDS("routes_jittered_quietest.Rds")
routes_jittered_balanced = readRDS("routes_jittered_balanced.Rds")
routes_jittered_fastest = readRDS("routes_jittered_fastest.Rds")
routes_jittered_500_quietest = readRDS("routes_jittered_500_quietest.Rds")
routes_jittered_500_balanced = readRDS("routes_jittered_500_balanced.Rds")
routes_jittered_500_fastest = readRDS("routes_jittered_500_fastest.Rds")
rnet_unjittered_quietest = overline(routes_unjittered_quietest, attrib = "Bike")
rnet_unjittered_balanced = overline(routes_unjittered_balanced, attrib = "Bike")
rnet_unjittered_fastest = overline(routes_unjittered_fastest, attrib = "Bike")
rnet_jittered_quietest = overline(routes_jittered_quietest, attrib = "Bike")
rnet_jittered_balanced = overline(routes_jittered_balanced, attrib = "Bike")
rnet_jittered_fastest = overline(routes_jittered_fastest, attrib = "Bike")
rnet_jittered_500_quietest = overline(routes_jittered_500_quietest, attrib = "Bike")
rnet_jittered_500_balanced = overline(routes_jittered_500_balanced, attrib = "Bike")
rnet_jittered_500_fastest = overline(routes_jittered_500_fastest, attrib = "Bike")
```

```{r, echo=FALSE}
# rnet_quiet = readRDS(url("https://github.com/U-Shift/biclar/releases/download/0.0.1/rnet_enmac_region_quietest_top_20000.Rds"))

counters_sf_joined = st_join(counters_sf,
                             rnet_unjittered_quietest %>% rename(Bikes_unjittered_quietest = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_unjittered_balanced %>% rename(Bikes_unjittered_balanced = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_unjittered_fastest %>% rename(Bikes_unjittered_fastest = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_quietest %>% rename(Bikes_jittered_quietest = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_balanced %>% rename(Bikes_jittered_balanced = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_fastest %>% rename(Bikes_jittered_fastest = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_500_quietest %>% rename(Bikes_jittered_500_quietest = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_500_balanced %>% rename(Bikes_jittered_500_balanced = Bike),
                             join = sf::st_nearest_feature)
counters_sf_joined = st_join(counters_sf_joined,
                             rnet_jittered_500_fastest %>% rename(Bikes_jittered_500_fastest = Bike),
                             join = sf::st_nearest_feature)
# # head(counters_sf_joined)
# corrplot::corrplot(counters_sf_joined %>% sf::st_drop_geometry())
# counters_sf_joined %>% 
#   sf::st_drop_geometry() %>% 
#   plot()
```

Figure 2 shoes and example of route network from jittered od.... and the counters.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tmap)
tmap_mode("View")

#map with route network and couters location. rnet lwd = Bikes

```



Although useful for visualising the complex and spatially diffuse reality of travel patterns, we found that the most valuable use of jittering is as a pre-processing stage before routing and route network generation.
Route networks generated from jittered desire lines are more diffuse, and potentially more realistic, than centroid-based desire lines.

We also found that the approach, implemented in Rust and with bindings to R and Python (in progress), is fast.
Benchmarks show that the approach can 'jitter' desire lines representing millions of trips in a major city in less than a minute on consumer hardware.

We also found that the results of jittering depend on the geographic input datasets representing start points and trip attractors, and the use of weights.

Table 1 shows the counter data vs modeled route network fit, with different routing and jittering parameters. We can observe that jittered OD pairs provide a better fit result, with disagregation. It is also noticed that "Balanced" routing option has

```{r}
results = tibble::tribble(
  ~`Jittering`, ~`Routing`, ~`Nrow`, ~`R-Squared`,
  "Unjittered", "quietest", nrow(od_lisbon_sf), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_unjittered_quietest),
  "Unjittered", "balanced", nrow(od_lisbon_sf), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_unjittered_balanced),
  "Unjittered", "fastest", nrow(od_lisbon_sf), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_unjittered_fastest),
  "Jittered, no disaggregation", "quietest", nrow(od_lisbon_jittered), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_quietest),
  "Jittered, no disaggregation", "balanced", nrow(od_lisbon_jittered), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_balanced),
  "Jittered, no disaggregation", "fastest", nrow(od_lisbon_jittered), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_fastest),
  "Jittered, 500 disaggregation", "quietest", nrow(od_lisbon_jittered_500), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_500_quietest),
  "Jittered, 500 disaggregation", "balanced", nrow(od_lisbon_jittered_500), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_500_balanced),
  "Jittered, 500 disaggregation", "fastest", nrow(od_lisbon_jittered_500), cor(counters_sf_joined$SumCiclistas, counters_sf_joined$Bikes_jittered_500_fastest),
  )
knitr::kable(results, digits = 2, booktabs = TRUE, caption = "Results showing counter/model fit for route networks generated from different routing and jittering parameters")
```

# Conclusion

Building on previous work , we have explored the relative importance of parameters that 'jitter' and disaggregate OD data to create more spatially diverse geographic representations of travel between zone *and* the routing settings used.
We found that the combination of careful selection of routing profiles, in addition to careful and iteratively selected jittering parameters is needed for realistic route network results, based on a case study of Lisbon, Portugal.
We cannot draw conclusions about the optimal settings for accurate route network generation in other cities because each route network and set of cycling preferences is different.
Future work should seek to test a wider range of jittering parameters in multiple case study areas with larger ground truth datasets.

# References
